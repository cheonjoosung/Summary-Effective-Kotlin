# Summary-Clean-Code

## 1.깨끗한코드
- 나쁜코드의 대가
  + 나쁜코드가 쌓일수록 코드의 생산성은 낮아진다.
    * 재설계를 위한 팀을 따로 두워서 진행을 하지만 쉽지 않다.
  + 관리자는 일정을 개발자는 좋은 코드를 만들어야 하는 현실적인 문제가 존재
- 깨끗한 코드
  + 한 가지의 목적만을 가지도록 소프트웨어 설계 원칙
  + 의도를 숨기지 않는 코드
  + 테스트케이스가 없으면 깨끗하지 않다는 말을 살짝 동의하기 어렵다. 
- 보이스카우트 원칙
  + 처음 왔을 때 보다 더 깨끗하게 해놓고 가라 -> 유지보수가 진행되어도 더러운 코드를
  코드로 만들지 마라

## 2.의미있는 이름
- 의도를 밝혀라
  + 의미를 전달할 수 있게 변수/함수 명 만들기
    - 리스트에 0번쨰를 4와 비교하는 코드를 의미를 전달할 수 있는 코드로..
  ```kotlin
  val d = 4
  val daySinceCreation = 4   
   
  fun getThem(): List<Int> {
    // 코드
    if (list[0] == 4) list.add(x)  
    return list
  }
  
  fun getFlaggedCells(): List<Int> {
    // 코드
    if (cell[status_value] == FLAGGED) 
        flaggedCellslist.add(cell)
    return flaggedCellslist
  }
  ```
  + 그릇된 정보를 피하라
    - o, 0, O & 1, l, i, I 구별이 힘듬
  + 의미 있게 구분
    - NameString vs String, Customer vs CustomerObject
    - getActiveAccount(), getActiveAccounts(), getActiveAccountInfo()
    - 매개변수에 의미없는 인자명보다는 사용처를 명확하게 쓰기
  + 발음하기 쉬운 이름 사용
    - 서버기반의 용어들은 축약어로 사용하고 이를 네트워크 통신으로 받아서 쓰면 곤란한 경우가 많다
    - DtaRcrd102 로 내려오지만 그대로 쓰면 발음도 어렵고 이해도 어렵다 DataRecord로 변경이 필요하다
  + 검색하기 쉬운 이름 사용
    - val PIE = 3.14 가 val p = 3.14 보다는 찾기가 편함
  + 인코딩 피하라
    - 옛날방식 mDest, mObject 
    - 인터페이스 ShapeFactoryImp IShapeFactory
  + 자신의 기억력을 자랑하지 마라
  + 클래스 이름 - 명사/명사구
  + 메소드 이름 - 동사/동사구
  + 기발한 이름은 피하라
  + 한 개념에 한 단어를 사용
    - 네트워크 통신 get, call, request
    - controller, manager, driver
  + 말장난을 하지 마라
    - 한 단어를 두 가지 목적으로 사용하면 안 됨
  + 맥락을 분명하게 하기
    - if-else 문 안에 다른 로직이 들어간다면 각각을 의미있는 함수로 만들고 호출하기
      
  

<br></br>

## 3.함수
- 작게 만들어라
  + if - else 가 여러개 중첩된 경우 풀어서 쓰는 것 보다 각 조건에 맞는 함수를 만들고
호출해서 쓰는게 가독성이 좋음
- 한가지만 해라
  + 하나의 함수에 2가지 이상의 기능이 있는 경우 영향도로 인해 자주 수정이 되고 이는
코드의 안정성도 낮추고 유지보수성도 좋지 않다. -> 추상화 수준이 높다
- 서술적인 이름을 사용
  + 모듈 내에서 함수 이름은 같은 문구/명사/동사를 사용 ex) 네트워크 get, call, request
의 혼용보다는 한가지로 통일
- 함수인수
- 부수효과를 일으키지 마라
  + 클래스 변수에 수정과 같은 로직?
- 명령과 조회를 분리하라
  + 뭔가를 수행하는 함수 vs 답하는 함수
- 오류 코드보다 예외를 사용하라
- 반복하지 마라
  + 중복하여 알고리즘 코드를 만들지 말고 하나로 관리
- 구조적 프로그래밍


<br></br>
## 4.주석
- 주석이 필요악?
  + 코드의 품질이 낮기에 추가 설명을 위해 존재하는 경우가 많음
  + 유지보수 되는 과정에서 코드는 고쳐지나 주석은 고쳐지지 않는 경우가 많음
- 주석보다는 코드로 의도를 표현하려고 노력해야 함
  + if (employee.flags & HOURLY_FLAG & age >65) 보다는 if (employee.isEligibleForFullBenefits()) 이
    더 이해하는데 좋아보인다.
- 좋은주석
  + 법적인 주석 - 저작권
  + 정보를 제공하는 주석
  + 의미 명료한 밝힌 주석 (테스트 케이스에 a == a, b != b 등)
  + 결과 경고 - 함수의 로직이 너무 올래거리는 경우 -> @Ignore 로 대체 가능
  + TODO 주석 
- 나쁜주석
  + 좋은 주석 이외의 경우는 대부분... 


<br></br>
## 5.형식맞추기
- 형식이 필요한 이유?
  + 개발자 간의 의사소통의 일환이고 추가적인 설명없이 더 빨리 이해하는데 도움이 된다
    * 적절한 행, 위애서 아래로, 개념은 빈행으로 분리, 세로 밀집도, 수직 거리(변수와 사용지점)
    * 인스턴스 변수는 클래스 맨처음 또는 맨마지막(가위규칙)
    + 들여쓰기

<br></br>
## 6.객체와 자료 구조
- 자료 추상화
  + 사용자가 구현을 모른 채 자료의 핵심 조작이 가능해야 함.
- 자료/객체 비대칭
  + 객체지향에서 새로운 함수를 추가하기 어렵다고 하는데.... 절차지향은 반대.. 상호보완적 관계를 가진다
- 디미터 법칙
  + 모듈은 자신이 조작하는 객체의 속사정을 몰라야 함 - 내부구조 노출을 하지 않는다.
- 자료 전달 객체
  + DTO, 빈구조, 네트워크 통신에서 사용하는 모델
- 결론
  + 객체는 동작을 공개하고 자료를 숨긴다 - 은닉 & 캡슐화


<br></br>
## 7.오류처리
- 오류 코드보다 예외를 사용하라.
  + if - else 문 처리보다는 try-catch를 사용하고 코틀린에서는 required, null run ?: 을
  활용하여 함수 파라미터의 적정성을 체크
- try-catch-finally
  + 자바에서는 finally 에서의 객체 close를 했을 때 JVM에 수거 시점이 애매하다고 하여
  try-with-resources 를 권장
  + ocp 를 위반할 수 있음.. 새로운 입센션을 추가했을 때 고쳐야 하는 범위가 문제
- 일반적인 예외 사용
  + 책에서는 다양한 커스텀 exception이 많이 사용하는데 이해하기 어려울 수 있으니.. 일반적인 것으로
  최대한 사용하는 것을 권장
- null을 반환 또는 전달하지 마라
  + 예외가 발생할 수 잇으므로... 반환하고 싶다면 어노테이션을 써야할 지도?
  + 코틀린에서는 type?.let이 가능하나 자바에서는 문제가 많이 발생할 수 있음


<br></br>
## 8.경계
- 외부 코드 사용하기, 경계 살피고, 익히기, log4j
 + 외부 소스 코드를 사용할 때 테스트가 필요