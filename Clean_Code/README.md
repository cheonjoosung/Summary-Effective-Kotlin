# Summary-Clean-Code

## 1.깨끗한코드
- 나쁜코드의 대가
  + 나쁜코드가 쌓일수록 코드의 생산성은 낮아진다.
    * 재설계를 위한 팀을 따로 두워서 진행을 하지만 쉽지 않다.
  + 관리자는 일정을 개발자는 좋은 코드를 만들어야 하는 현실적인 문제가 존재
- 깨끗한 코드
  + 한 가지의 목적만을 가지도록 소프트웨어 설계 원칙
  + 의도를 숨기지 않는 코드
  + 테스트케이스가 없으면 깨끗하지 않다는 말을 살짝 동의하기 어렵다. 
- 보이스카우트 원칙
  + 처음 왔을 때 보다 더 깨끗하게 해놓고 가라 -> 유지보수가 진행되어도 더러운 코드를
  코드로 만들지 마라

## 2.의미있는 이름
- 의도를 밝혀라
  + 의미를 전달할 수 있게 변수/함수 명 만들기
    - 리스트에 0번쨰를 4와 비교하는 코드를 의미를 전달할 수 있는 코드로..
  ```kotlin
  val d = 4
  val daySinceCreation = 4   
   
  fun getThem(): List<Int> {
    // 코드
    if (list[0] == 4) list.add(x)  
    return list
  }
  
  fun getFlaggedCells(): List<Int> {
    // 코드
    if (cell[status_value] == FLAGGED) 
        flaggedCellslist.add(cell)
    return flaggedCellslist
  }
  ```
  + 그릇된 정보를 피하라
    - o, 0, O & 1, l, i, I 구별이 힘듬
  + 의미 있게 구분
    - NameString vs String, Customer vs CustomerObject
    - getActiveAccount(), getActiveAccounts(), getActiveAccountInfo()
    - 매개변수에 의미없는 인자명보다는 사용처를 명확하게 쓰기
  + 발음하기 쉬운 이름 사용
    - 서버기반의 용어들은 축약어로 사용하고 이를 네트워크 통신으로 받아서 쓰면 곤란한 경우가 많다
    - DtaRcrd102 로 내려오지만 그대로 쓰면 발음도 어렵고 이해도 어렵다 DataRecord로 변경이 필요하다
  + 검색하기 쉬운 이름 사용
    - val PIE = 3.14 가 val p = 3.14 보다는 찾기가 편함
  + 인코딩 피하라
    - 옛날방식 mDest, mObject 
    - 인터페이스 ShapeFactoryImp IShapeFactory
  + 자신의 기억력을 자랑하지 마라
  + 클래스 이름 - 명사/명사구
  + 메소드 이름 - 동사/동사구
  + 기발한 이름은 피하라
  + 한 개념에 한 단어를 사용
    - 네트워크 통신 get, call, request
    - controller, manager, driver
  + 말장난을 하지 마라
    - 한 단어를 두 가지 목적으로 사용하면 안 됨
  + 맥락을 분명하게 하기
    - if-else 문 안에 다른 로직이 들어간다면 각각을 의미있는 함수로 만들고 호출하기
      
  

<br></br>

## 3.함수
- 작게 만들어라
  + if - else 가 여러개 중첩된 경우 풀어서 쓰는 것 보다 각 조건에 맞는 함수를 만들고
호출해서 쓰는게 가독성이 좋음
- 한가지만 해라
  + 하나의 함수에 2가지 이상의 기능이 있는 경우 영향도로 인해 자주 수정이 되고 이는
코드의 안정성도 낮추고 유지보수성도 좋지 않다. -> 추상화 수준이 높다
- 서술적인 이름을 사용
  + 모듈 내에서 함수 이름은 같은 문구/명사/동사를 사용 ex) 네트워크 get, call, request
의 혼용보다는 한가지로 통일
- 함수인수
- 부수효과를 일으키지 마라
  + 클래스 변수에 수정과 같은 로직?
- 명령과 조회를 분리하라
  + 뭔가를 수행하는 함수 vs 답하는 함수
- 오류 코드보다 예외를 사용하라
- 반복하지 마라
  + 중복하여 알고리즘 코드를 만들지 말고 하나로 관리
- 구조적 프로그래밍


<br></br>
## 4.주석
- 주석이 필요악?
  + 코드의 품질이 낮기에 추가 설명을 위해 존재하는 경우가 많음
  + 유지보수 되는 과정에서 코드는 고쳐지나 주석은 고쳐지지 않는 경우가 많음
- 주석보다는 코드로 의도를 표현하려고 노력해야 함
  + if (employee.flags & HOURLY_FLAG & age >65) 보다는 if (employee.isEligibleForFullBenefits()) 이
    더 이해하는데 좋아보인다.
- 좋은주석
  + 법적인 주석 - 저작권
  + 정보를 제공하는 주석
  + 의미 명료한 밝힌 주석 (테스트 케이스에 a == a, b != b 등)
  + 결과 경고 - 함수의 로직이 너무 올래거리는 경우 -> @Ignore 로 대체 가능
  + TODO 주석 
- 나쁜주석
  + 좋은 주석 이외의 경우는 대부분... 


<br></br>
## 5.형식맞추기
- 형식이 필요한 이유?
  + 개발자 간의 의사소통의 일환이고 추가적인 설명없이 더 빨리 이해하는데 도움이 된다
    * 적절한 행, 위애서 아래로, 개념은 빈행으로 분리, 세로 밀집도, 수직 거리(변수와 사용지점)
    * 인스턴스 변수는 클래스 맨처음 또는 맨마지막(가위규칙)
    + 들여쓰기

<br></br>
## 6.객체와 자료 구조
- 자료 추상화
  + 사용자가 구현을 모른 채 자료의 핵심 조작이 가능해야 함.
- 자료/객체 비대칭
  + 객체지향에서 새로운 함수를 추가하기 어렵다고 하는데.... 절차지향은 반대.. 상호보완적 관계를 가진다
- 디미터 법칙
  + 모듈은 자신이 조작하는 객체의 속사정을 몰라야 함 - 내부구조 노출을 하지 않는다.
- 자료 전달 객체
  + DTO, 빈구조, 네트워크 통신에서 사용하는 모델
- 결론
  + 객체는 동작을 공개하고 자료를 숨긴다 - 은닉 & 캡슐화


<br></br>
## 7.오류처리
- 오류 코드보다 예외를 사용하라.
  + if - else 문 처리보다는 try-catch를 사용하고 코틀린에서는 required, null run ?: 을
  활용하여 함수 파라미터의 적정성을 체크
- try-catch-finally
  + 자바에서는 finally 에서의 객체 close를 했을 때 JVM에 수거 시점이 애매하다고 하여
  try-with-resources 를 권장
  + ocp 를 위반할 수 있음.. 새로운 입센션을 추가했을 때 고쳐야 하는 범위가 문제
- 일반적인 예외 사용
  + 책에서는 다양한 커스텀 exception이 많이 사용하는데 이해하기 어려울 수 있으니.. 일반적인 것으로
  최대한 사용하는 것을 권장
- null을 반환 또는 전달하지 마라
  + 예외가 발생할 수 잇으므로... 반환하고 싶다면 어노테이션을 써야할 지도?
  + 코틀린에서는 type?.let이 가능하나 자바에서는 문제가 많이 발생할 수 있음


<br></br>
## 8.경계
- 외부 코드 사용하기, 경계 살피고, 익히기, log4j
  + 외부 소스 코드를 사용할 때 테스트가 필요


<br></br>
## 9. 단위 테스트
- TDD
  + 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다
  + 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위테스트 작성
  + 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성
- 깨긋한 테스트 코드 유지
  + 로직을 수정하는 데 짧게 걸린다
  + 유연성, 유지보수성, 재사용


<br></br>
## 10. 클래스
- 체계
  + 변수 + 공개함수
  + 캡슐화
- 클래스는 작아야 한다
  + 크기의 절대성이 아니라 단일책임의 원칙 (SRP)
  + 응집도 - 메소드와 변수간의 논리적인 단위로 잘 묶여있다.
- 변경하기 쉬운 클래스
  + 코드는 변경될 수 밖에 없음 -> 추상 클래스를 사용하고 그를 상속바다 닫힌 상태
  + 변경으로부터 격리


<br></br>
## 11. 시스템
- 도시를 세운다면?
  + 모듈화 & 추상화 필요
- 시스템 제작 & 사용
  + 관심사의 분리
  + 메인 분리 & 팩토리 & 의존성 주입
- 확장
  + TDD, 리팩토링
- 자바프록시
- AOP 프레임워크


<br></br>
## 12. 창발성
- 창발 또는 떠오름 현상은 하위 계층에는 없는 특성이나 행동이 상위 계층에서 자발적으로 돌연히 출현하는 현상
- 설계규칙
  + 모든 테스트를 실행라
      * DIP 적용, DI, 인터페이스, 추상화 -> 결합도를 낮추기
  + 리팩토링
      * 테스트 케이스가 있으면 괜찮음
- 중복을 없애기
  + 리팩토링과 연관 됨
- 표현하라
  + 좋은 이름, 함수&클래스 크기를 줄이기, 표준 명칭 사용
  

<br></br>
## 13. 동시성
- 동시성이 필요한 이휴?
  + 결합을 없애는 전략
    * 무엇과 언제를 분리
- 난관
  + 두 쓰레드가 같은 변수를 동시에 참조하면 무슨 값이 나올지 모른다 -> 잘못된 결과일 확률이 높다.
- 동시성 방어 원칙
  + 단일 책임원칙 
    * 다른 코드와 분리
    * 임계영역을 synchronized 키워드로 보호
    * 자료를 캡슐화로 공유 자료를 최대한 줄여라
    * 자료 사본을 사용하라
    * 스레드는 가능한 독립적으로 구현
- 라이브러리를 이해라
  + 레드 환경에 안전한 컬렉션 - ReentaranLock, Semaphore, CountDownLatch
  + 실행 모델을 이해하라 - 한정된 자원, 상호 배제, 기아, 데드락, 라이브락
  + 생산자-소비자
  + 읽기-쓰기 스레드가 공유 자원을 이따금 갱신(처리율)
  + 식사하는 철학자들
- 동기화하는 메서드 사이에 존재하는 의존성을 이해하
- 동기화하는 부분을 작게 만들어라
  + synchronized 최대한 적은 영역으로
- 올바른 종료 코드는 구현하기 어려움
  + 갈끔하게 종료하는 코드가 쉽지 않기에 데드락이 발생할 수 있음
- 스레드 코드 테스트하기
  + 말이 안되는 실패는 잠정적인 스레드 문제로 취급 (다중스레드)
  + 다중 쓰레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
  + 다중 쓰레드 코드 부분을 다양한 환경에 쉽게 넣을 수 있게 스레드 코드 구현
  + 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성
  + 프로세서 수보다 많은 스레드를 돌려보라


<br></br>
## 14. 점진적인 개선
-